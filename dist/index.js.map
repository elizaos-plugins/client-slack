{"version":3,"sources":["../src/slack-client.ts","../src/messages.ts","../src/templates.ts","../src/environment.ts","../src/actions/chat_with_attachments.ts","../src/actions/summarize_conversation.ts","../src/types/slack-types.ts","../src/providers/channelState.ts","../src/services/slack.service.ts","../src/index.ts"],"sourcesContent":["import { Character, Client as ElizaClient, IAgentRuntime } from \"@elizaos/core\";\nimport { elizaLogger } from \"@elizaos/core\";\nimport { WebClient } from \"@slack/web-api\";\nimport express, { Request } from \"express\";\nimport { EventEmitter } from \"events\";\nimport { MessageManager } from \"./messages\";\nimport { validateSlackConfig } from \"./environment\";\nimport chat_with_attachments from \"./actions/chat_with_attachments\";\nimport summarize_conversation from \"./actions/summarize_conversation\";\n// import transcribe_media from './actions/transcribe_media';\nimport { channelStateProvider } from \"./providers/channelState\";\nimport { SlackService } from \"./services/slack.service\";\n\ninterface SlackRequest extends Request {\n    rawBody?: Buffer;\n}\n\nexport class SlackClient extends EventEmitter {\n    private client: WebClient;\n    private runtime: IAgentRuntime;\n    private server: express.Application;\n    private messageManager: MessageManager;\n    private botUserId: string;\n    private character: Character;\n    private signingSecret: string;\n\n    constructor(runtime: IAgentRuntime) {\n        super();\n        elizaLogger.log(\"🚀 Initializing SlackClient...\");\n        this.runtime = runtime;\n        this.character = runtime.character;\n\n        const token = runtime.getSetting(\"SLACK_BOT_TOKEN\");\n        this.signingSecret = runtime.getSetting(\"SLACK_SIGNING_SECRET\");\n\n        if (!token) throw new Error(\"SLACK_BOT_TOKEN is required\");\n        if (!this.signingSecret)\n            throw new Error(\"SLACK_SIGNING_SECRET is required\");\n\n        this.client = new WebClient(token);\n        this.server = express();\n\n        this.server.use(express.raw({ type: \"application/json\" }));\n        this.server.use((req: SlackRequest, res, next) => {\n            if (req.body) {\n                req.rawBody = Buffer.from(req.body);\n                try {\n                    req.body = JSON.parse(req.body.toString());\n                } catch (error) {\n                    elizaLogger.error(\n                        \"❌ [PARSE] Failed to parse request body:\",\n                        error\n                    );\n                }\n            }\n            next();\n        });\n    }\n\n    private async handleEvent(event: any) {\n        elizaLogger.debug(\"🎯 [EVENT] Processing event:\", {\n            type: event.type,\n            user: event.user,\n            channel: event.channel,\n            text: event.text?.slice(0, 100),\n        });\n\n        try {\n            if (event.type === \"message\" || event.type === \"app_mention\") {\n                await this.messageManager.handleMessage(event);\n            }\n        } catch (error) {\n            elizaLogger.error(\"❌ [EVENT] Error handling event:\", error);\n        }\n    }\n\n    private async verifyPermissions() {\n        elizaLogger.debug(\"🔒 [PERMISSIONS] Verifying bot permissions...\");\n\n        try {\n            // Test channel list access with all types\n            const channels = await this.client.conversations.list({\n                types: \"public_channel,private_channel,im,mpim\",\n            });\n\n            if (!channels.ok) {\n                throw new Error(`Failed to list channels: ${channels.error}`);\n            }\n\n            elizaLogger.debug(\"📋 [PERMISSIONS] Channel access verified\");\n\n            // Test message sending (to self)\n            const testMessage = await this.client.chat.postMessage({\n                channel: this.botUserId,\n                text: \"Permission test message\",\n            });\n\n            if (!testMessage.ok) {\n                throw new Error(\n                    `Failed to send test message: ${testMessage.error}`\n                );\n            }\n\n            elizaLogger.debug(\"💬 [PERMISSIONS] Message sending verified\");\n\n            elizaLogger.debug(\"✅ [PERMISSIONS] All permissions verified\");\n        } catch (error: any) {\n            elizaLogger.error(\n                \"❌ [PERMISSIONS] Permission verification failed:\",\n                error\n            );\n            elizaLogger.error(\n                \"Please ensure the following scopes are added to your Slack app:\"\n            );\n            elizaLogger.error(\"- app_mentions:read     (for mentions)\");\n            elizaLogger.error(\"- channels:history      (for public channels)\");\n            elizaLogger.error(\"- channels:read         (for channel info)\");\n            elizaLogger.error(\"- chat:write            (for sending messages)\");\n            elizaLogger.error(\"- groups:history        (for private channels)\");\n            elizaLogger.error(\n                \"- groups:read           (for private channel info)\"\n            );\n            elizaLogger.error(\"- im:history            (for DMs)\");\n            elizaLogger.error(\"- im:read               (for DM info)\");\n            elizaLogger.error(\"- im:write              (for sending DMs)\");\n            elizaLogger.error(\"- mpim:history          (for group DMs)\");\n            elizaLogger.error(\"- mpim:read             (for group DM info)\");\n            elizaLogger.error(\"- users:read            (for user info)\");\n            throw new Error(\"Permission verification failed\");\n        }\n    }\n\n    async start() {\n        try {\n            elizaLogger.log(\"Starting Slack client...\");\n\n            const config = await validateSlackConfig(this.runtime);\n\n            // Initialize and register Slack service\n            const slackService = new SlackService();\n            await slackService.initialize(this.runtime);\n            await this.runtime.registerService(slackService);\n\n            // Get detailed bot info\n            const auth = await this.client.auth.test();\n            if (!auth.ok) throw new Error(\"Failed to authenticate with Slack\");\n\n            this.botUserId = auth.user_id as string;\n            elizaLogger.debug(\"🤖 [INIT] Bot info:\", {\n                user_id: auth.user_id,\n                bot_id: auth.bot_id,\n                team_id: auth.team_id,\n                user: auth.user,\n                team: auth.team,\n            });\n\n            // Verify bot user details\n            try {\n                const botInfo = await this.client.users.info({\n                    user: this.botUserId,\n                });\n\n                elizaLogger.debug(\"👤 [BOT] Bot user details:\", {\n                    name: botInfo.user?.name,\n                    real_name: botInfo.user?.real_name,\n                    is_bot: botInfo.user?.is_bot,\n                    is_app_user: botInfo.user?.is_app_user,\n                    status: botInfo.user?.profile?.status_text,\n                });\n            } catch (error) {\n                elizaLogger.error(\n                    \"❌ [BOT] Failed to verify bot details:\",\n                    error\n                );\n            }\n\n            // Verify permissions\n            await this.verifyPermissions();\n\n            // Initialize message manager\n            this.messageManager = new MessageManager(\n                this.client,\n                this.runtime,\n                this.botUserId\n            );\n\n            // Register actions and providers\n            this.runtime.registerAction(chat_with_attachments);\n            this.runtime.registerAction(summarize_conversation);\n            // this.runtime.registerAction(transcribe_media);\n            this.runtime.providers.push(channelStateProvider);\n\n            // Add request logging middleware\n            this.server.use((req: SlackRequest, res, next) => {\n                elizaLogger.debug(\"🌐 [HTTP] Incoming request:\", {\n                    method: req.method,\n                    path: req.path,\n                    headers: req.headers,\n                    body: req.body,\n                    query: req.query,\n                    timestamp: new Date().toISOString(),\n                });\n                next();\n            });\n\n            // Setup event handling endpoint\n            this.server.post(\n                \"/slack/events\",\n                async (req: SlackRequest, res) => {\n                    try {\n                        elizaLogger.debug(\n                            \"📥 [REQUEST] Incoming Slack event:\",\n                            {\n                                type: req.body?.type,\n                                event: req.body?.event?.type,\n                                challenge: req.body?.challenge,\n                                raw: JSON.stringify(req.body, null, 2),\n                            }\n                        );\n\n                        // Handle URL verification\n                        if (req.body?.type === \"url_verification\") {\n                            elizaLogger.debug(\n                                \"🔑 [VERIFICATION] Challenge received:\",\n                                req.body.challenge\n                            );\n                            return res.send(req.body.challenge);\n                        }\n\n                        // Process the event\n                        if (req.body?.event) {\n                            elizaLogger.debug(\"🎯 [EVENT] Processing event:\", {\n                                type: req.body.event.type,\n                                user: req.body.event.user,\n                                text: req.body.event.text,\n                                channel: req.body.event.channel,\n                                ts: req.body.event.ts,\n                            });\n                            await this.handleEvent(req.body.event);\n                        } else {\n                            elizaLogger.warn(\n                                \"⚠️ [EVENT] Received request without event data\"\n                            );\n                        }\n\n                        // Acknowledge receipt\n                        res.status(200).send();\n                    } catch (error) {\n                        elizaLogger.error(\n                            \"❌ [ERROR] Error processing request:\",\n                            error\n                        );\n                        res.status(500).json({\n                            error: \"Internal server error\",\n                        });\n                    }\n                }\n            );\n\n            // Setup interactions endpoint\n            this.server.post(\n                \"/slack/interactions\",\n                async (req: SlackRequest, res) => {\n                    try {\n                        elizaLogger.debug(\n                            \"🔄 [INTERACTION] Incoming interaction:\",\n                            {\n                                type: req.body?.type,\n                                action: req.body?.action,\n                                callback_id: req.body?.callback_id,\n                                raw: JSON.stringify(req.body, null, 2),\n                            }\n                        );\n\n                        // Always acknowledge interaction\n                        res.status(200).send();\n                    } catch (error) {\n                        elizaLogger.error(\n                            \"❌ [ERROR] Error processing interaction:\",\n                            error\n                        );\n                        res.status(500).json({\n                            error: \"Internal server error\",\n                        });\n                    }\n                }\n            );\n\n            // Start server\n            const port = config.SLACK_SERVER_PORT;\n            this.server.listen(port, () => {\n                elizaLogger.success(\n                    `🚀 [SERVER] Slack event server is running on port ${port}`\n                );\n                elizaLogger.success(\n                    `✅ [INIT] Slack client successfully started for character ${this.character.name}`\n                );\n                elizaLogger.success(\n                    `🤖 [READY] Bot user: @${auth.user} (${this.botUserId})`\n                );\n                elizaLogger.success(\n                    `📡 [EVENTS] Listening for events at: /slack/events`\n                );\n                elizaLogger.success(\n                    `💡 [INTERACTIONS] Listening for interactions at: /slack/interactions`\n                );\n                elizaLogger.success(`💡 [HELP] To interact with the bot:`);\n                elizaLogger.success(\n                    `   1. Direct message: Find @${auth.user} in DMs`\n                );\n                elizaLogger.success(\n                    `   2. Channel: Mention @${auth.user} in any channel`\n                );\n            });\n        } catch (error) {\n            elizaLogger.error(\"❌ [INIT] Failed to start Slack client:\", error);\n            throw error;\n        }\n    }\n\n    async stop() {\n        elizaLogger.log(\"Stopping Slack client...\");\n        if (this.server) {\n            await new Promise<void>((resolve) => {\n                this.server.listen().close(() => {\n                    elizaLogger.log(\"Server stopped\");\n                    resolve();\n                });\n            });\n        }\n    }\n}","import {\n    stringToUuid,\n    getEmbeddingZeroVector,\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    ModelClass,\n    Memory,\n    Content,\n    State,\n    elizaLogger,\n    HandlerCallback,\n} from \"@elizaos/core\";\nimport {\n    slackMessageHandlerTemplate,\n    slackShouldRespondTemplate,\n} from \"./templates\";\nimport { WebClient } from \"@slack/web-api\";\nimport { IAgentRuntime } from \"@elizaos/core\";\n\nexport class MessageManager {\n    private client: WebClient;\n    private runtime: IAgentRuntime;\n    private botUserId: string;\n    private processedEvents: Set<string> = new Set();\n    private messageProcessingLock: Set<string> = new Set();\n    private processedMessages: Map<string, number> = new Map();\n\n    constructor(client: WebClient, runtime: IAgentRuntime, botUserId: string) {\n        console.log(\"📱 Initializing MessageManager...\");\n        this.client = client;\n        this.runtime = runtime;\n        this.botUserId = botUserId;\n        console.log(\"MessageManager initialized with botUserId:\", botUserId);\n\n        // Clear old processed messages and events every hour\n        setInterval(() => {\n            const oneHourAgo = Date.now() - 3600000;\n\n            // Clear old processed messages\n            for (const [key, timestamp] of this.processedMessages.entries()) {\n                if (timestamp < oneHourAgo) {\n                    this.processedMessages.delete(key);\n                }\n            }\n\n            // Clear old processed events\n            this.processedEvents.clear();\n        }, 3600000);\n    }\n\n    private generateEventKey(event: any): string {\n        // Create a unique key that includes all relevant event data\n        // Normalize event type to handle message and app_mention as the same type\n        const eventType = event.type === \"app_mention\" ? \"message\" : event.type;\n\n        const components = [\n            event.ts, // Timestamp\n            event.channel, // Channel ID\n            eventType, // Normalized event type\n            event.user, // User ID\n            event.thread_ts, // Thread timestamp (if any)\n        ].filter(Boolean); // Remove any undefined/null values\n\n        const key = components.join(\"-\");\n        console.log(\"\\n=== EVENT DETAILS ===\");\n        console.log(\"Event Type:\", event.type);\n        console.log(\"Event TS:\", event.ts);\n        console.log(\"Channel:\", event.channel);\n        console.log(\"User:\", event.user);\n        console.log(\"Thread TS:\", event.thread_ts);\n        console.log(\"Generated Key:\", key);\n        return key;\n    }\n\n    private cleanMessage(text: string): string {\n        elizaLogger.debug(\"🧹 [CLEAN] Cleaning message text:\", text);\n        // Remove bot mention\n        const cleaned = text\n            .replace(new RegExp(`<@${this.botUserId}>`, \"g\"), \"\")\n            .trim();\n        elizaLogger.debug(\"✨ [CLEAN] Cleaned result:\", cleaned);\n        return cleaned;\n    }\n\n    private async _shouldRespond(message: any, state: State): Promise<boolean> {\n        console.log(\"\\n=== SHOULD_RESPOND PHASE ===\");\n        console.log(\"🔍 Step 1: Evaluating if should respond to message\");\n\n        // Always respond to direct mentions\n        if (\n            message.type === \"app_mention\" ||\n            message.text?.includes(`<@${this.botUserId}>`)\n        ) {\n            console.log(\"✅ Direct mention detected - will respond\");\n            return true;\n        }\n\n        // Always respond in direct messages\n        if (message.channel_type === \"im\") {\n            console.log(\"✅ Direct message detected - will respond\");\n            return true;\n        }\n\n        // Check if we're in a thread and we've participated\n        if (\n            message.thread_ts &&\n            state.recentMessages?.includes(this.runtime.agentId)\n        ) {\n            console.log(\"✅ Active thread participant - will respond\");\n            return true;\n        }\n\n        // Only use LLM for ambiguous cases\n        console.log(\"🤔 Step 2: Using LLM to decide response\");\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates?.slackShouldRespondTemplate ||\n                this.runtime.character.templates?.shouldRespondTemplate ||\n                slackShouldRespondTemplate,\n        });\n\n        console.log(\"🔄 Step 3: Calling generateShouldRespond\");\n        const response = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.SMALL,\n        });\n\n        console.log(`✅ Step 4: LLM decision received: ${response}`);\n        return response === \"RESPOND\";\n    }\n\n    private async _generateResponse(\n        memory: Memory,\n        state: State,\n        context: string\n    ): Promise<Content> {\n        console.log(\"\\n=== GENERATE_RESPONSE PHASE ===\");\n        console.log(\"🔍 Step 1: Starting response generation\");\n\n        // Generate response only once\n        console.log(\"🔄 Step 2: Calling LLM for response\");\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n        console.log(\"✅ Step 3: LLM response received\");\n\n        if (!response) {\n            console.error(\"❌ No response from generateMessageResponse\");\n            return {\n                text: \"I apologize, but I'm having trouble generating a response right now.\",\n                source: \"slack\",\n            };\n        }\n\n        // If response includes a CONTINUE action but there's no direct mention or thread,\n        // remove the action to prevent automatic continuation\n        if (\n            response.action === \"CONTINUE\" &&\n            !memory.content.text?.includes(`<@${this.botUserId}>`) &&\n            !state.recentMessages?.includes(memory.id)\n        ) {\n            console.log(\n                \"⚠️ Step 4: Removing CONTINUE action - not a direct interaction\"\n            );\n            delete response.action;\n        }\n\n        console.log(\"✅ Step 5: Returning generated response\");\n        return response;\n    }\n\n    public async handleMessage(event: any) {\n        console.log(\"\\n=== MESSAGE_HANDLING PHASE ===\");\n        console.log(\"🔍 Step 1: Received new message event\");\n\n        // Skip if no event data\n        if (!event || !event.ts || !event.channel) {\n            console.log(\"⚠️ Invalid event data - skipping\");\n            return;\n        }\n\n        // Generate event key for deduplication\n        const eventKey = this.generateEventKey(event);\n\n        // Check if we've already processed this event\n        if (this.processedEvents.has(eventKey)) {\n            console.log(\"⚠️ Event already processed - skipping\");\n            console.log(\"Existing event key:\", eventKey);\n            console.log(\"Original event type:\", event.type);\n            console.log(\"Duplicate prevention working as expected\");\n            return;\n        }\n\n        // Add to processed events immediately\n        console.log(\"✅ New event - processing:\", eventKey);\n        console.log(\"Event type being processed:\", event.type);\n        this.processedEvents.add(eventKey);\n\n        // Generate message key for processing lock\n        const messageKey = eventKey; // Use same key for consistency\n        const currentTime = Date.now();\n\n        try {\n            // Check if message is currently being processed\n            if (this.messageProcessingLock.has(messageKey)) {\n                console.log(\n                    \"⚠️ Message is currently being processed - skipping\"\n                );\n                return;\n            }\n\n            // Add to processing lock\n            console.log(\"🔒 Step 2: Adding message to processing lock\");\n            this.messageProcessingLock.add(messageKey);\n\n            try {\n                // Ignore messages from bots (including ourselves)\n                if (event.bot_id || event.user === this.botUserId) {\n                    console.log(\"⚠️ Message from bot or self - skipping\");\n                    return;\n                }\n\n                // Clean the message text\n                console.log(\"🧹 Step 3: Cleaning message text\");\n                const cleanedText = this.cleanMessage(event.text || \"\");\n                if (!cleanedText) {\n                    console.log(\"⚠️ Empty message after cleaning - skipping\");\n                    return;\n                }\n\n                // Generate unique IDs\n                console.log(\"🔑 Step 4: Generating conversation IDs\");\n                const roomId = stringToUuid(\n                    `${event.channel}-${this.runtime.agentId}`\n                );\n                const userId = stringToUuid(\n                    `${event.user}-${this.runtime.agentId}`\n                );\n                const messageId = stringToUuid(\n                    `${event.ts}-${this.runtime.agentId}`\n                );\n\n                // Create initial memory\n                console.log(\"💾 Step 5: Creating initial memory\");\n                const content: Content = {\n                    text: cleanedText,\n                    source: \"slack\",\n                    inReplyTo: event.thread_ts\n                        ? stringToUuid(\n                              `${event.thread_ts}-${this.runtime.agentId}`\n                          )\n                        : undefined,\n                    attachments: event.text\n                        ? [\n                              {\n                                  id: stringToUuid(`${event.ts}-attachment`),\n                                  url: \"\", // Since this is text content, no URL is needed\n                                  title: \"Text Attachment\",\n                                  source: \"slack\",\n                                  description:\n                                      \"Text content from Slack message\",\n                                  text: cleanedText,\n                              },\n                          ]\n                        : undefined,\n                };\n\n                const memory: Memory = {\n                    id: messageId,\n                    userId,\n                    agentId: this.runtime.agentId,\n                    roomId,\n                    content,\n                    createdAt: new Date(parseFloat(event.ts) * 1000).getTime(),\n                    embedding: getEmbeddingZeroVector(),\n                };\n\n                // Add memory\n                if (content.text) {\n                    console.log(\"💾 Step 6: Saving initial memory\");\n                    await this.runtime.messageManager.createMemory(memory);\n                }\n\n                // Initial state composition\n                console.log(\"🔄 Step 7: Composing initial state\");\n                let state = await this.runtime.composeState(\n                    { content, userId, agentId: this.runtime.agentId, roomId },\n                    {\n                        slackClient: this.client,\n                        slackEvent: event,\n                        agentName: this.runtime.character.name,\n                        senderName: event.user_name || event.user,\n                    }\n                );\n\n                // Update state with recent messages\n                console.log(\"🔄 Step 8: Updating state with recent messages\");\n                state = await this.runtime.updateRecentMessageState(state);\n\n                // Check if we should respond\n                console.log(\"🤔 Step 9: Checking if we should respond\");\n                const shouldRespond = await this._shouldRespond(event, state);\n\n                if (shouldRespond) {\n                    console.log(\n                        \"✅ Step 10: Should respond - generating response\"\n                    );\n                    const context = composeContext({\n                        state,\n                        template:\n                            this.runtime.character.templates\n                                ?.slackMessageHandlerTemplate ||\n                            slackMessageHandlerTemplate,\n                    });\n\n                    const responseContent = await this._generateResponse(\n                        memory,\n                        state,\n                        context\n                    );\n\n                    if (responseContent?.text) {\n                        console.log(\"📤 Step 11: Preparing to send response\");\n\n                        const callback: HandlerCallback = async (\n                            content: Content\n                        ) => {\n                            try {\n                                console.log(\n                                    \" Step 12: Executing response callback\"\n                                );\n                                const result =\n                                    await this.client.chat.postMessage({\n                                        channel: event.channel,\n                                        text:\n                                            content.text ||\n                                            responseContent.text,\n                                        thread_ts: event.thread_ts,\n                                    });\n\n                                console.log(\n                                    \"💾 Step 13: Creating response memory\"\n                                );\n                                const responseMemory: Memory = {\n                                    id: stringToUuid(\n                                        `${result.ts}-${this.runtime.agentId}`\n                                    ),\n                                    userId: this.runtime.agentId,\n                                    agentId: this.runtime.agentId,\n                                    roomId,\n                                    content: {\n                                        ...content,\n                                        text:\n                                            content.text ||\n                                            responseContent.text,\n                                        inReplyTo: messageId,\n                                    },\n                                    createdAt: Date.now(),\n                                    embedding: getEmbeddingZeroVector(),\n                                };\n\n                                console.log(\n                                    \"✓ Step 14: Marking message as processed\"\n                                );\n                                this.processedMessages.set(\n                                    messageKey,\n                                    currentTime\n                                );\n\n                                console.log(\n                                    \"💾 Step 15: Saving response memory\"\n                                );\n                                await this.runtime.messageManager.createMemory(\n                                    responseMemory\n                                );\n\n                                return [responseMemory];\n                            } catch (error) {\n                                console.error(\"❌ Error in callback:\", error);\n                                return [];\n                            }\n                        };\n\n                        console.log(\"📤 Step 16: Sending initial response\");\n                        const responseMessages =\n                            await callback(responseContent);\n\n                        console.log(\n                            \"🔄 Step 17: Updating state after response\"\n                        );\n                        state =\n                            await this.runtime.updateRecentMessageState(state);\n\n                        if (responseContent.action) {\n                            console.log(\"⚡ Step 18: Processing actions\");\n                            await this.runtime.processActions(\n                                memory,\n                                responseMessages,\n                                state,\n                                callback\n                            );\n                        }\n                    }\n                } else {\n                    console.log(\"⏭️ Should not respond - skipping\");\n                    this.processedMessages.set(messageKey, currentTime);\n                }\n            } finally {\n                console.log(\n                    \"🔓 Final Step: Removing message from processing lock\"\n                );\n                this.messageProcessingLock.delete(messageKey);\n            }\n        } catch (error) {\n            console.error(\"❌ Error in message handling:\", error);\n            this.messageProcessingLock.delete(messageKey);\n        }\n    }\n}\n","import { messageCompletionFooter, shouldRespondFooter } from \"@elizaos/core\";\n\nexport const slackShouldRespondTemplate =\n    `# Task: Decide if {{agentName}} should respond.\nAbout {{agentName}}:\n{{bio}}\n\n# INSTRUCTIONS: Determine if {{agentName}} should respond to the message and participate in the conversation. Do not comment. Just respond with \"RESPOND\" or \"IGNORE\" or \"STOP\".\n\n# RESPONSE EXAMPLES\n<user 1>: Hey everyone, what's up?\n<user 2>: Not much, just working\nResult: [IGNORE]\n\n{{agentName}}: I can help with that task\n<user 1>: thanks!\n<user 2>: @{{agentName}} can you explain more?\nResult: [RESPOND]\n\n<user>: @{{agentName}} shut up\nResult: [STOP]\n\n<user>: Hey @{{agentName}}, can you help me with something?\nResult: [RESPOND]\n\n<user>: @{{agentName}} please stop\nResult: [STOP]\n\n<user>: I need help\n{{agentName}}: How can I help you?\n<user>: Not you, I need someone else\nResult: [IGNORE]\n\nResponse options are [RESPOND], [IGNORE] and [STOP].\n\n{{agentName}} is in a Slack channel with other users and is very mindful about not being disruptive.\nRespond with [RESPOND] to messages that:\n- Directly mention @{{agentName}}\n- Are follow-ups to {{agentName}}'s previous messages\n- Are relevant to ongoing conversations {{agentName}} is part of\n\nRespond with [IGNORE] to messages that:\n- Are not directed at {{agentName}}\n- Are general channel chatter\n- Are very short or lack context\n- Are part of conversations {{agentName}} isn't involved in\n\nRespond with [STOP] when:\n- Users explicitly ask {{agentName}} to stop or be quiet\n- The conversation with {{agentName}} has naturally concluded\n- Users express frustration with {{agentName}}\n\nIMPORTANT: {{agentName}} should err on the side of [IGNORE] if there's any doubt about whether to respond.\nOnly respond when explicitly mentioned or when clearly part of an ongoing conversation.\n\n{{recentMessages}}\n\n# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are not directed at {{agentName}}.\n` + shouldRespondFooter;\n\nexport const slackMessageHandlerTemplate =\n    `# Action Examples\n{{actionExamples}}\n(Action examples are for reference only. Do not use the information from them in your response.)\n\n# Knowledge\n{{knowledge}}\n\n# Task: Generate dialog and actions for the character {{agentName}} in Slack.\nAbout {{agentName}}:\n{{bio}}\n{{lore}}\n\nExamples of {{agentName}}'s dialog and actions:\n{{characterMessageExamples}}\n\n{{providers}}\n\n{{attachments}}\n\n{{actions}}\n\n# Capabilities\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n# Conversation Flow Rules\n1. Only continue the conversation if the user has explicitly mentioned {{agentName}} or is directly responding to {{agentName}}'s last message\n2. Do not use the CONTINUE action unless explicitly asked to continue by the user\n3. Wait for user input before generating additional responses\n4. Keep responses focused and concise\n5. If a conversation is naturally concluding, let it end gracefully\n\n{{messageDirections}}\n\n{{recentMessages}}\n\n# Instructions: Write the next message for {{agentName}}. Include an action, if appropriate. {{actionNames}}\nRemember to follow the conversation flow rules above.\n` + messageCompletionFooter;\n","import { IAgentRuntime } from \"@elizaos/core\";\nimport { elizaLogger } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nexport const slackEnvSchema = z.object({\n    SLACK_APP_ID: z.string().min(1, \"Slack application ID is required\"),\n    SLACK_CLIENT_ID: z.string().min(1, \"Slack client ID is required\"),\n    SLACK_CLIENT_SECRET: z.string().min(1, \"Slack client secret is required\"),\n    SLACK_SIGNING_SECRET: z.string().min(1, \"Slack signing secret is required\"),\n    SLACK_VERIFICATION_TOKEN: z\n        .string()\n        .min(1, \"Slack verification token is required\"),\n    SLACK_BOT_TOKEN: z.string().min(1, \"Slack bot token is required\"),\n    SLACK_SERVER_PORT: z\n        .string()\n        .optional()\n        .transform((val) => (val ? parseInt(val) : 3000)),\n});\n\nexport type SlackConfig = z.infer<typeof slackEnvSchema>;\n\nexport async function validateSlackConfig(\n    runtime: IAgentRuntime\n): Promise<SlackConfig> {\n    try {\n        elizaLogger.debug(\n            \"Validating Slack configuration with runtime settings\"\n        );\n        const config = {\n            SLACK_APP_ID:\n                runtime.getSetting(\"SLACK_APP_ID\") || process.env.SLACK_APP_ID,\n            SLACK_CLIENT_ID:\n                runtime.getSetting(\"SLACK_CLIENT_ID\") ||\n                process.env.SLACK_CLIENT_ID,\n            SLACK_CLIENT_SECRET:\n                runtime.getSetting(\"SLACK_CLIENT_SECRET\") ||\n                process.env.SLACK_CLIENT_SECRET,\n            SLACK_SIGNING_SECRET:\n                runtime.getSetting(\"SLACK_SIGNING_SECRET\") ||\n                process.env.SLACK_SIGNING_SECRET,\n            SLACK_VERIFICATION_TOKEN:\n                runtime.getSetting(\"SLACK_VERIFICATION_TOKEN\") ||\n                process.env.SLACK_VERIFICATION_TOKEN,\n            SLACK_BOT_TOKEN:\n                runtime.getSetting(\"SLACK_BOT_TOKEN\") ||\n                process.env.SLACK_BOT_TOKEN,\n            SLACK_SERVER_PORT:\n                runtime.getSetting(\"SLACK_SERVER_PORT\") ||\n                process.env.SLACK_SERVER_PORT,\n        };\n\n        elizaLogger.debug(\"Parsing configuration with schema\", config);\n        const validated = slackEnvSchema.parse(config);\n        elizaLogger.debug(\"Configuration validated successfully\");\n        return validated;\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((e) => `${e.path.join(\".\")}: ${e.message}`)\n                .join(\"\\n\");\n            elizaLogger.error(\n                \"Configuration validation failed:\",\n                errorMessages\n            );\n            throw new Error(\n                `Slack configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import {\n    composeContext,\n    generateText,\n    trimTokens,\n    parseJSONObjectFromText,\n    getModelSettings,\n} from \"@elizaos/core\";\nimport {\n    Action,\n    ActionExample,\n    Content,\n    HandlerCallback,\n    Handler,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n} from \"@elizaos/core\";\n\nexport const summarizationTemplate = `# Summarized so far (we are adding to this)\n{{currentSummary}}\n\n# Current attachments we are summarizing\n{{attachmentsWithText}}\n\nSummarization objective: {{objective}}\n\n# Instructions: Summarize the attachments. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details based on the objective. Only respond with the new summary text.`;\n\nexport const attachmentIdsTemplate = `# Messages we are summarizing\n{{recentMessages}}\n\n# Instructions: {{senderName}} is requesting a summary of specific attachments. Your goal is to determine their objective, along with the list of attachment IDs to summarize.\nThe \"objective\" is a detailed description of what the user wants to summarize based on the conversation.\nThe \"attachmentIds\" is an array of attachment IDs that the user wants to summarize. If not specified, default to including all attachments from the conversation.\n\nYour response must be formatted as a JSON block with this structure:\n\\`\\`\\`json\n{\n  \"objective\": \"<What the user wants to summarize>\",\n  \"attachmentIds\": [\"<Attachment ID 1>\", \"<Attachment ID 2>\", ...]\n}\n\\`\\`\\`\n`;\n\nconst getAttachmentIds = async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State\n): Promise<{ objective: string; attachmentIds: string[] } | null> => {\n    const context = composeContext({\n        state,\n        template: attachmentIdsTemplate,\n    });\n\n    for (let i = 0; i < 5; i++) {\n        const response = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        const parsedResponse = parseJSONObjectFromText(response) as {\n            objective: string;\n            attachmentIds: string[];\n        } | null;\n\n        if (parsedResponse?.objective && parsedResponse?.attachmentIds) {\n            return parsedResponse;\n        }\n    }\n    return null;\n};\n\nconst summarizeAction: Action = {\n    name: \"CHAT_WITH_ATTACHMENTS\",\n    similes: [\n        \"CHAT_WITH_ATTACHMENT\",\n        \"SUMMARIZE_FILES\",\n        \"SUMMARIZE_FILE\",\n        \"SUMMARIZE_ATACHMENT\",\n        \"CHAT_WITH_PDF\",\n        \"ATTACHMENT_SUMMARY\",\n        \"RECAP_ATTACHMENTS\",\n        \"SUMMARIZE_FILE\",\n        \"SUMMARIZE_VIDEO\",\n        \"SUMMARIZE_AUDIO\",\n        \"SUMMARIZE_IMAGE\",\n        \"SUMMARIZE_DOCUMENT\",\n        \"SUMMARIZE_LINK\",\n        \"ATTACHMENT_SUMMARY\",\n        \"FILE_SUMMARY\",\n    ],\n    description:\n        \"Answer a user request informed by specific attachments based on their IDs. If a user asks to chat with a PDF, or wants more specific information about a link or video or anything else they've attached, this is the action to use.\",\n    validate: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        _state: State | undefined\n    ): Promise<boolean> => {\n        if (message.content.source !== \"slack\") {\n            return false;\n        }\n\n        const keywords: string[] = [\n            \"attachment\",\n            \"summary\",\n            \"summarize\",\n            \"research\",\n            \"pdf\",\n            \"video\",\n            \"audio\",\n            \"image\",\n            \"document\",\n            \"link\",\n            \"file\",\n            \"attachment\",\n            \"summarize\",\n            \"code\",\n            \"report\",\n            \"write\",\n            \"details\",\n            \"information\",\n            \"talk\",\n            \"chat\",\n            \"read\",\n            \"listen\",\n            \"watch\",\n        ];\n\n        return keywords.some((keyword) =>\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\n        );\n    },\n    handler: (async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State | undefined,\n        options: any,\n        callback: HandlerCallback\n    ): Promise<Content> => {\n        const currentState =\n            state ?? ((await runtime.composeState(message)) as State);\n\n        const callbackData: Content = {\n            text: \"\",\n            action: \"CHAT_WITH_ATTACHMENTS_RESPONSE\",\n            source: message.content.source,\n            attachments: [],\n        };\n\n        const attachmentData = await getAttachmentIds(\n            runtime,\n            message,\n            currentState\n        );\n        if (!attachmentData) {\n            console.error(\"Couldn't get attachment IDs from message\");\n            await callback(callbackData);\n            return callbackData;\n        }\n\n        const { objective, attachmentIds } = attachmentData;\n\n        const attachments = currentState.recentMessagesData\n            .filter(\n                (msg) =>\n                    msg.content.attachments &&\n                    msg.content.attachments.length > 0\n            )\n            .flatMap((msg) => msg.content.attachments)\n            .filter((attachment) => {\n                if (!attachment) return false;\n                return (\n                    attachmentIds\n                        .map((attch) => attch.toLowerCase().slice(0, 5))\n                        .includes(attachment.id.toLowerCase().slice(0, 5)) ||\n                    attachmentIds.some((id) => {\n                        const attachmentId = id.toLowerCase().slice(0, 5);\n                        return attachment.id\n                            .toLowerCase()\n                            .includes(attachmentId);\n                    })\n                );\n            });\n\n        const attachmentsWithText = attachments\n            .map((attachment) => {\n                if (!attachment) return \"\";\n                return `# ${attachment.title}\\n${attachment.text}`;\n            })\n            .filter((text) => text !== \"\")\n            .join(\"\\n\\n\");\n\n        let currentSummary = \"\";\n\n        const modelSettings = getModelSettings(\n            runtime.character.modelProvider,\n            ModelClass.SMALL\n        );\n        const chunkSize = modelSettings.maxOutputTokens;\n\n        currentState.attachmentsWithText = attachmentsWithText;\n        currentState.objective = objective;\n\n        const template = await trimTokens(\n            summarizationTemplate,\n            chunkSize + 500,\n            runtime\n        );\n        const context = composeContext({\n            state: currentState,\n            template,\n        });\n\n        const summary = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        currentSummary = currentSummary + \"\\n\" + summary;\n\n        if (!currentSummary) {\n            console.error(\"No summary found!\");\n            await callback(callbackData);\n            return callbackData;\n        }\n\n        callbackData.text = currentSummary.trim();\n\n        if (\n            callbackData.text &&\n            (currentSummary.trim()?.split(\"\\n\").length < 4 ||\n                currentSummary.trim()?.split(\" \").length < 100)\n        ) {\n            callbackData.text = `Here is the summary:\n\\`\\`\\`md\n${currentSummary.trim()}\n\\`\\`\\`\n`;\n            await callback(callbackData);\n        } else if (currentSummary.trim()) {\n            const summaryFilename = `content/summary_${Date.now()}`;\n            await runtime.cacheManager.set(summaryFilename, currentSummary);\n\n            callbackData.text = `I've attached the summary of the requested attachments as a text file.`;\n            await callback(callbackData, [summaryFilename]);\n        } else {\n            await callback(callbackData);\n        }\n\n        return callbackData;\n    }) as Handler,\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can you summarize the PDF I just shared?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I'll analyze the PDF and provide a summary for you.\",\n                    action: \"CHAT_WITH_ATTACHMENTS\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Could you look at these documents and tell me what they're about?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I'll review the documents and provide a summary of their contents.\",\n                    action: \"CHAT_WITH_ATTACHMENTS\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n};\n\nexport default summarizeAction;\n","import {\n    composeContext,\n    generateText,\n    splitChunks,\n    trimTokens,\n    parseJSONObjectFromText,\n    getModelSettings,\n} from \"@elizaos/core\";\nimport { getActorDetails } from \"@elizaos/core\";\nimport {\n    Action,\n    ActionExample,\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    Media,\n    Memory,\n    ModelClass,\n    State,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport { ISlackService, SLACK_SERVICE_TYPE } from \"../types/slack-types\";\n\nexport const summarizationTemplate = `# Summarized so far (we are adding to this)\n{{currentSummary}}\n\n# Current conversation chunk we are summarizing (includes attachments)\n{{memoriesWithAttachments}}\n\nSummarization objective: {{objective}}\n\n# Instructions: Summarize the conversation so far. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details to the objective. Only respond with the new summary text.\nYour response should be extremely detailed and include any and all relevant information.`;\n\nexport const dateRangeTemplate = `# Messages we are summarizing (the conversation is continued after this)\n{{recentMessages}}\n\n# Instructions: {{senderName}} is requesting a summary of the conversation. Your goal is to determine their objective, along with the range of dates that their request covers.\nThe \"objective\" is a detailed description of what the user wants to summarize based on the conversation. If they just ask for a general summary, you can either base it off the conversation if the summary range is very recent, or set the object to be general, like \"a detailed summary of the conversation between all users\".\n\nThe \"start\" and \"end\" are the range of dates that the user wants to summarize, relative to the current time. The format MUST be a number followed by a unit, like:\n- \"5 minutes ago\"\n- \"2 hours ago\"\n- \"1 day ago\"\n- \"30 seconds ago\"\n\nFor example:\n\\`\\`\\`json\n{\n  \"objective\": \"a detailed summary of the conversation between all users\",\n  \"start\": \"2 hours ago\",\n  \"end\": \"0 minutes ago\"\n}\n\\`\\`\\`\n\nIf the user asks for \"today\", use \"24 hours ago\" as start and \"0 minutes ago\" as end.\nIf no time range is specified, default to \"2 hours ago\" for start and \"0 minutes ago\" for end.\n`;\n\nconst getDateRange = async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State\n): Promise<{ objective: string; start: number; end: number } | undefined> => {\n    state = (await runtime.composeState(message)) as State;\n\n    const context = composeContext({\n        state,\n        template: dateRangeTemplate,\n    });\n\n    for (let i = 0; i < 5; i++) {\n        const response = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        const parsedResponse = parseJSONObjectFromText(response) as {\n            objective: string;\n            start: string | number;\n            end: string | number;\n        } | null;\n\n        if (\n            parsedResponse?.objective &&\n            parsedResponse?.start &&\n            parsedResponse?.end\n        ) {\n            // Parse time strings like \"5 minutes ago\", \"2 hours ago\", etc.\n            const parseTimeString = (timeStr: string): number | null => {\n                const match = timeStr.match(\n                    /^(\\d+)\\s+(second|minute|hour|day)s?\\s+ago$/i\n                );\n                if (!match) return null;\n\n                const [_, amount, unit] = match;\n                const value = parseInt(amount);\n\n                if (isNaN(value)) return null;\n\n                const multipliers: { [key: string]: number } = {\n                    second: 1000,\n                    minute: 60 * 1000,\n                    hour: 60 * 60 * 1000,\n                    day: 24 * 60 * 60 * 1000,\n                };\n\n                const multiplier = multipliers[unit.toLowerCase()];\n                if (!multiplier) return null;\n\n                return value * multiplier;\n            };\n\n            const startTime = parseTimeString(parsedResponse.start as string);\n            const endTime = parseTimeString(parsedResponse.end as string);\n\n            if (startTime === null || endTime === null) {\n                elizaLogger.error(\n                    \"Invalid time format in response\",\n                    parsedResponse\n                );\n                continue;\n            }\n\n            return {\n                objective: parsedResponse.objective,\n                start: Date.now() - startTime,\n                end: Date.now() - endTime,\n            };\n        }\n    }\n\n    return undefined;\n};\n\nconst summarizeAction: Action = {\n    name: \"SUMMARIZE_CONVERSATION\",\n    similes: [\n        \"RECAP\",\n        \"RECAP_CONVERSATION\",\n        \"SUMMARIZE_CHAT\",\n        \"SUMMARIZATION\",\n        \"CHAT_SUMMARY\",\n        \"CONVERSATION_SUMMARY\",\n    ],\n    description: \"Summarizes the conversation and attachments.\",\n    validate: async (\n        _runtime: IAgentRuntime,\n        message: Memory,\n        _state: State | undefined\n    ): Promise<boolean> => {\n        if (message.content.source !== \"slack\") {\n            return false;\n        }\n\n        const keywords: string[] = [\n            \"summarize\",\n            \"summarization\",\n            \"summary\",\n            \"recap\",\n            \"report\",\n            \"overview\",\n            \"review\",\n            \"rundown\",\n            \"wrap-up\",\n            \"brief\",\n            \"debrief\",\n            \"abstract\",\n            \"synopsis\",\n            \"outline\",\n            \"digest\",\n            \"abridgment\",\n            \"condensation\",\n            \"encapsulation\",\n            \"essence\",\n            \"gist\",\n            \"main points\",\n            \"key points\",\n            \"key takeaways\",\n            \"bulletpoint\",\n            \"highlights\",\n            \"tldr\",\n            \"tl;dr\",\n            \"in a nutshell\",\n            \"bottom line\",\n            \"long story short\",\n            \"sum up\",\n            \"sum it up\",\n            \"short version\",\n            \"bring me up to speed\",\n            \"catch me up\",\n        ];\n\n        return keywords.some((keyword) =>\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\n        );\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: any,\n        callback: HandlerCallback\n    ): Promise<Content> => {\n        const currentState = (await runtime.composeState(message)) as State;\n\n        const callbackData: Content = {\n            text: \"\",\n            action: \"SUMMARIZATION_RESPONSE\",\n            source: message.content.source,\n            attachments: [],\n        };\n\n        // 1. Extract date range from the message\n        const dateRange = await getDateRange(runtime, message, currentState);\n        if (!dateRange) {\n            elizaLogger.error(\"Couldn't determine date range from message\");\n            callbackData.text =\n                \"I couldn't determine the time range to summarize. Please try asking for a specific period like 'last hour' or 'today'.\";\n            await callback(callbackData);\n            return callbackData;\n        }\n\n        const { objective, start, end } = dateRange;\n\n        // 2. Get memories from the database\n        const memories = await runtime.messageManager.getMemories({\n            roomId: message.roomId,\n            start,\n            end,\n            count: 10000,\n            unique: false,\n        });\n\n        if (!memories || memories.length === 0) {\n            callbackData.text =\n                \"I couldn't find any messages in that time range to summarize.\";\n            await callback(callbackData);\n            return callbackData;\n        }\n\n        const actors = await getActorDetails({\n            runtime: runtime as IAgentRuntime,\n            roomId: message.roomId,\n        });\n\n        const actorMap = new Map(actors.map((actor) => [actor.id, actor]));\n\n        const formattedMemories = memories\n            .map((memory) => {\n                const actor = actorMap.get(memory.userId);\n                const userName =\n                    actor?.name || actor?.username || \"Unknown User\";\n                const attachments = memory.content.attachments\n                    ?.map((attachment: Media) => {\n                        if (!attachment) return \"\";\n                        return `---\\nAttachment: ${attachment.id}\\n${attachment.description || \"\"}\\n${attachment.text || \"\"}\\n---`;\n                    })\n                    .filter((text) => text !== \"\")\n                    .join(\"\\n\");\n                return `${userName}: ${memory.content.text}\\n${attachments || \"\"}`;\n            })\n            .join(\"\\n\");\n\n        let currentSummary = \"\";\n\n        const modelSettings = getModelSettings(\n            runtime.character.modelProvider,\n            ModelClass.SMALL\n        );\n        const chunkSize = modelSettings.maxOutputTokens;\n\n        const chunks = await splitChunks(formattedMemories, chunkSize, 0);\n\n        currentState.memoriesWithAttachments = formattedMemories;\n        currentState.objective = objective;\n\n        // Only process one chunk at a time and stop after getting a valid summary\n        for (let i = 0; i < chunks.length; i++) {\n            const chunk = chunks[i];\n            currentState.currentSummary = currentSummary;\n            currentState.currentChunk = chunk;\n\n            const template = await trimTokens(\n                summarizationTemplate,\n                chunkSize + 500,\n                runtime\n            );\n\n            const context = composeContext({\n                state: currentState,\n                template,\n            });\n\n            const summary = await generateText({\n                runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            if (summary) {\n                currentSummary = currentSummary + \"\\n\" + summary;\n                break; // Stop after getting first valid summary\n            }\n        }\n\n        if (!currentSummary.trim()) {\n            callbackData.text =\n                \"I wasn't able to generate a summary of the conversation.\";\n            await callback(callbackData);\n            return callbackData;\n        }\n\n        // Format dates consistently\n        const formatDate = (timestamp: number) => {\n            const date = new Date(timestamp);\n            const pad = (n: number) => (n < 10 ? `0${n}` : n);\n            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;\n        };\n\n        try {\n            // Get the user's name for the summary header\n            const requestingUser = actorMap.get(message.userId);\n            const userName =\n                requestingUser?.name ||\n                requestingUser?.username ||\n                \"Unknown User\";\n\n            const summaryContent = `Summary of conversation from ${formatDate(start)} to ${formatDate(end)}\n\nHere is a detailed summary of the conversation between ${userName} and ${runtime.character.name}:\\n\\n${currentSummary.trim()}`;\n\n            // If summary is long, upload as a file\n            if (summaryContent.length > 1000) {\n                const summaryFilename = `summary_${Date.now()}.txt`;\n                elizaLogger.debug(\"Uploading summary file to Slack...\");\n\n                try {\n                    // Save file content\n                    await runtime.cacheManager.set(\n                        summaryFilename,\n                        summaryContent\n                    );\n\n                    // Get the Slack service from runtime\n                    const slackService = runtime.getService(\n                        SLACK_SERVICE_TYPE\n                    ) as ISlackService;\n                    if (!slackService?.client) {\n                        elizaLogger.error(\n                            \"Slack service not found or not properly initialized\"\n                        );\n                        throw new Error(\"Slack service not found\");\n                    }\n\n                    // Upload file using Slack's API\n                    elizaLogger.debug(\n                        `Uploading file ${summaryFilename} to channel ${message.roomId}`\n                    );\n                    const uploadResult = await slackService.client.files.upload(\n                        {\n                            channels: message.roomId,\n                            filename: summaryFilename,\n                            title: \"Conversation Summary\",\n                            content: summaryContent,\n                            initial_comment: `I've created a summary of the conversation from ${formatDate(start)} to ${formatDate(end)}.`,\n                        }\n                    );\n\n                    if (uploadResult.ok) {\n                        elizaLogger.success(\n                            \"Successfully uploaded summary file to Slack\"\n                        );\n                        callbackData.text = `I've created a summary of the conversation from ${formatDate(start)} to ${formatDate(end)}. You can find it in the thread above.`;\n                    } else {\n                        elizaLogger.error(\n                            \"Failed to upload file to Slack:\",\n                            uploadResult.error\n                        );\n                        throw new Error(\"Failed to upload file to Slack\");\n                    }\n                } catch (error) {\n                    elizaLogger.error(\"Error uploading summary file:\", error);\n                    // Fallback to sending as a message\n                    callbackData.text = summaryContent;\n                }\n            } else {\n                // For shorter summaries, just send as a message\n                callbackData.text = summaryContent;\n            }\n\n            await callback(callbackData);\n            return callbackData;\n        } catch (error) {\n            elizaLogger.error(\"Error in summary generation:\", error);\n            callbackData.text =\n                \"I encountered an error while generating the summary. Please try again.\";\n            await callback(callbackData);\n            return callbackData;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can you give me a detailed report on what we're talking about?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I'll analyze the conversation and provide a summary for you.\",\n                    action: \"SUMMARIZE_CONVERSATION\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Please summarize our discussion from the last hour, including any shared files.\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I'll review the conversation and shared content to create a comprehensive summary.\",\n                    action: \"SUMMARIZE_CONVERSATION\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n};\n\nexport default summarizeAction;\n","import { WebClient } from \"@slack/web-api\";\nimport { Service, ServiceType } from \"@elizaos/core\";\n\nexport interface SlackConfig {\n    appId: string;\n    clientId: string;\n    clientSecret: string;\n    signingSecret: string;\n    verificationToken: string;\n    botToken: string;\n    botId: string;\n}\n\nexport interface SlackClientContext {\n    client: any;\n    config: SlackConfig;\n}\n\nexport interface SlackMessage {\n    text: string;\n    userId: string;\n    channelId: string;\n    threadTs?: string;\n    attachments?: Array<{\n        type: string;\n        url: string;\n        title: string;\n        size: number;\n    }>;\n}\n\n// We'll temporarily use TEXT_GENERATION as our service type\n// This is not ideal but allows us to work within current constraints\nexport const SLACK_SERVICE_TYPE = ServiceType.TEXT_GENERATION;\n\n// Interface extending core Service\nexport interface ISlackService extends Service {\n    client: WebClient;\n}\n","import { IAgentRuntime, Memory, Provider, State } from \"@elizaos/core\";\n\ninterface SlackEvent {\n    channel: string;\n    channel_type: string;\n    thread_ts?: string;\n    user?: string;\n    team?: string;\n}\n\nexport const channelStateProvider: Provider = {\n    get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\n        const slackEvent = state?.slackEvent as SlackEvent | undefined;\n        if (!slackEvent) {\n            return \"\";\n        }\n\n        const agentName = state?.agentName || \"The agent\";\n        const senderName = state?.senderName || \"someone\";\n        const channelId = slackEvent.channel;\n        const channelType = slackEvent.channel_type;\n\n        // For direct messages\n        if (channelType === \"im\") {\n            return `${agentName} is currently in a direct message conversation with ${senderName}`;\n        }\n\n        // For channel messages\n        let response = `${agentName} is currently having a conversation in the Slack channel <#${channelId}>`;\n\n        // Add thread context if in a thread\n        if (slackEvent.thread_ts) {\n            response += ` in a thread`;\n        }\n\n        // Add team context if available\n        if (slackEvent.team) {\n            response += ` in the workspace ${slackEvent.team}`;\n        }\n\n        return response;\n    },\n};\n","import { Service, IAgentRuntime, ServiceType } from \"@elizaos/core\";\nimport { WebClient } from \"@slack/web-api\";\nimport { ISlackService } from \"../types/slack-types\";\n\nexport class SlackService extends Service implements ISlackService {\n    public client: WebClient;\n\n    static get serviceType(): ServiceType {\n        return ServiceType.SLACK;\n    }\n\n    get serviceType(): ServiceType {\n        return ServiceType.SLACK;\n    }\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {\n        const token = runtime.getSetting(\"SLACK_BOT_TOKEN\");\n        if (!token) {\n            throw new Error(\"SLACK_BOT_TOKEN is required\");\n        }\n        this.client = new WebClient(token);\n    }\n}\n","import { SlackClient } from \"./slack-client\";\n\nexport const SlackClientInterface = {\n    name: 'slack',\n    config: {},\n    start: async (runtime: any) => {\n        const client = new SlackClient(runtime);\n        await client.start();\n        return client as any;\n    },\n    stop: async (_runtime: any) => {\n        console.warn(\"Slack client stopping...\");\n    },\n};\nexport default SlackClientInterface;\n"],"mappings":"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","names":["elizaLogger","WebClient","content","elizaLogger","composeContext","ModelClass","composeContext","generateText","trimTokens","parseJSONObjectFromText","getModelSettings","ModelClass","elizaLogger","summarizationTemplate","composeContext","generateText","ModelClass","parseJSONObjectFromText","elizaLogger","summarizeAction","getModelSettings","trimTokens","Service","ServiceType","elizaLogger","WebClient","_a","_b","_c","_d","_e","_f"]}